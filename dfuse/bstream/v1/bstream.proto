syntax = "proto3";

package dfuse.bstream.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/dfuse-io/pbgo/dfuse/bstream/v1;pbbstream";

service BlockStream {
  rpc Blocks(BlockRequest) returns (stream Block);
}


message BlockRequest {
  // Number of blocks we want to get in burst upon connection, on a best effort basis.
  int64 burst = 1;

  // Type of blocks we're after here, is it 'ethereum' data, 'eos', etc.. The server can fail early
  // if he doesn't match the data he serves (services mismatch, etc..)
  string content_type = 2;

  // Whether we can assume the data will come ordered, unless there is a chain reorganization.
  // mindreaders output ordered data, whereas relayers can output unordered data.
  // The server can fail early if the assumption of the caller cannot be fulfilled.
  enum Order {
    UNSPECIFIED = 0;
    ORDERED = 1;
    UNORDERED = 2;
  }
  Order order = 3;

  string requester = 4;
  uint64 mandatory_first_block_num = 5; // if non-zero, the value of 'burst' is ignored and the blockstream must start at this exact block num or return an error.
}

message Block {
  uint64 number = 1;
  string id = 2;
  string previous_id = 3;
  google.protobuf.Timestamp timestamp = 4;
  uint64 lib_num = 5;

  Protocol payload_kind = 6;
  int32 payload_version = 7;
  bytes payload_buffer = 8;
}

enum Protocol {
  UNKNOWN = 0;
  EOS = 1;
  ETH = 2;
}

// This service serves unexecuted mempool transactions
service TransactionStream {
  rpc Transactions(TransactionRequest) returns (stream Transaction);
}

message TransactionRequest {
}

message Transaction {
  string id = 1;  // hash or ID of the transaction
  Protocol payload_protocol = 6;
  bytes payload_buffer = 8;
}
